####################################################################################################
#
# Pyterate - Sphinx add-ons to create API documentation for Python projects
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################

####################################################################################################

import logging
import os
import tempfile

import nbformat
from nbformat import v4 as nbv4

####################################################################################################

from ..Jupyter import JupyterClient
from ..Template import TemplateAggregator
from ..Tools.Path import remove_extension
from ..Tools.Timestamp import timestamp
from .Dom.Dom import Dom, TextChunk
from .Dom.Markups import (
    CommentChunk,
    RstChunk,
    CodeChunk, InteractiveCodeChunk, GuardedCodeChunk,
    OutputChunk,
    FigureChunk
)
from .Dom.FigureMarkups import ImageChunk, ExternalFigureChunk
from .Dom.Registry import MarkupRegistry
from .FigureEvaluator import FigureEvaluator

####################################################################################################

_module_logger = logging.getLogger(__name__)

####################################################################################################

class ParseError(Exception):

    ##############################################

    def __init__(self, message, line):

        self._message = message
        self._line = line

    ##############################################

    def __repr__(self):

        return "{0.message} on line\n{0._line}".format(self)

####################################################################################################

class Document:

    """ This class is responsible to process an document. """

    _logger = _module_logger.getChild('Document')

    ##############################################

    def __init__(self, topic, input_file, language):

        self._topic = topic
        self._input_file = input_file
        self._basename = remove_extension(input_file)
        self._language = language

        path = topic.join_path(input_file)
        self._is_link = os.path.islink(path)
        self._path = os.path.realpath(path) # input path

        if self._is_link:
            factory = self.factory
            path = factory.join_rst_document_path(os.path.relpath(self._path, factory.documents_path))
            self._rst_path = remove_extension(path) + '.rst'
        else:
            self._rst_path = self._topic.join_rst_path(self.rst_filename)

    ##############################################

    @property
    def topic(self):
        return self._topic

    @property
    def topic_path(self):
        return self._topic.path

    @property
    def topic_rst_path(self):
        return self._topic.rst_path

    @property
    def factory(self):
        return self._topic.factory

    @property
    def settings(self):
        return self._topic.settings

    @property
    def language(self):
        return self._language

    @property
    def path(self):
        return self._path

    @property
    def basename(self):
        return self._basename

    @property
    def rst_filename(self):
        return self._basename + '.rst'

    @property
    def nb_filename(self):
        return self._basename + '.ipynb' # Fixme

    @property
    def rst_inner_path(self):
        return os.path.sep + os.path.relpath(self._rst_path, self.factory.rst_source_path)

    ##############################################

    @property
    def is_link(self):
        return self._is_link

    ##############################################

    def read(self):

        # Fixme: update doc
        # Fixme: API ??? called process_document()

        # Must be called first !

        """Parse the source code and extract chunks of codes, RST contents, plot and Tikz figures.  The
        source code is annoted using comment lines starting with special directives of the form
        *#directive name#*.  RST content lines start with *#!#*.  We can include a figure using
        *#lfig#*, a figure generated by matplotlib using the directive *#fig#*, tikz figure using
        *#tz#* and the content of a file using *#itxt#* and *#i#* for codes.  Comment that must be
        skipped start with *#?#*.  Hidden code start with *#h#*.  The directive *#o#* is used to
        split the output and to instruct to include the previous chunk.  RST content can be
        formatted with variable from the locals dictionary using *@<@...@>@* instead of *{...}*.

        """

        with open(self._path) as fh:
            source = fh.readlines()

        dom = self._source_to_chunks(source)
        self._dom = self._post_process_dom(dom)

        # for chunk in self._dom:
        #     print('\n' + '#'*50)
        #     print(chunk)

    ##############################################

    @property
    def source_timestamp(self):
        return timestamp(self._path)

    ##############################################

    @property
    def rst_timestamp(self):

        if os.path.exists(self._rst_path):
            return timestamp(self._rst_path)
        else:
            return -1

    ##############################################

    def __bool__(self):
        """Return True if source is older than rst."""
        return self.source_timestamp > self.rst_timestamp

    ##############################################

    def run_code(self):

        self._logger.info("\nRun document " + self._path)

        has_error = False
        with tempfile.TemporaryDirectory() as working_directory:
            jupyter_client = JupyterClient(working_directory, kernel=self._language.jupyter_kernel)
            code = self._language.setup_code.format(file=self._path)
            jupyter_client.run_cell(code)
            for chunk in self._dom.iter_on_code_chunks():
                code = chunk.to_code()
                # self._logger.info('Execute\n{}'.format(code))
                outputs = jupyter_client.run_cell(code)
                if outputs:
                    output = outputs[0]
                    # self._logger.info('Output {0.output_type}\n{0}'.format(output))
                    chunk.outputs = outputs
                for output in outputs:
                    if output.is_error and not isinstance(chunk, GuardedCodeChunk):
                        has_error = True
                        self._logger.error(
                            "Error in document {}\n".format(self._path) +
                            str(code) + '\n\n' +
                            str(output)
                        )

        if has_error:
            self._logger.error("Failed to run document {}".format(self._path))
            self.factory.register_failure(self)

    ##############################################

    def symlink_source(self, source_path):

        source = self._topic.join_path(source_path)
        basename = os.path.basename(source_path)
        target = self._topic.join_rst_path(basename)

        if not os.path.exists(target):
            os.symlink(source, target)

        return basename

    ##############################################

    def make_external_figure(self, force):

        for chunk in self._dom:
            if isinstance(chunk, ExternalFigureChunk):
                if force or chunk:
                    chunk.make_figure()

    ##############################################

    def _parse_line(self, line):

        markup = None
        open_markup = False
        close_markup = False
        parsed_line = line

        def is_valid_makup(markup):
            if not MarkupRegistry.is_valid_makup(markup):
                raise ParseError("Invalid markup", line)

        def is_valid_enclosing_makup(markup):
            if not MarkupRegistry.is_valid_enclosing_makup(markup):
                raise ParseError("Invalid markup", line)

        def push_stack(markup):
            if not self._stack:
                self._stack.append(markup)
            else:
                raise ParseError("Nested markup", line)

        def pop_stack(markup):
            if self._stack:
                opening_markup = self._stack.pop()
                if opening_markup != markup:
                    raise ParseError("Unbalanced and mismatch markup", line)
            else:
                raise ParseError("Unbalanced markup", line)

        if line.startswith(self._language.left_markup):
            right = line.find(self._language.right_markup, 1)
            if right != -1:
                markup = line[1:right]
                if self._language.open_markup in markup:
                    markup = markup[1]
                    is_valid_enclosing_makup(markup)
                    open_markup = True
                    parsed_line = None
                    push_stack(markup)
                elif self._language.close_markup in markup:
                    markup = markup[0]
                    is_valid_enclosing_makup(markup)
                    close_markup = True
                    parsed_line = None
                    pop_stack(markup)
                elif markup:
                    is_valid_makup(markup)
                    parsed_line = line[right+1:]
                    # strip space
                    if parsed_line and parsed_line[0] == ' ':
                        parsed_line = parsed_line[1:]
                else:
                    markup = None
                    # Fixme: ??? raise ParseError('Invalid Markup', line)

        enclosing_markup = open_markup or close_markup

        if self._stack:
            if markup is None:
                markup = self._stack[-1] # use enclosing markup
            elif not enclosing_markup:
                raise ParseError("Nested markup", line)

        if markup is None:
            markup_cls = CodeChunk
        else:
            markup_cls = MarkupRegistry.markup_to_class(markup)

        return markup_cls, parsed_line

    ##############################################

    def _source_to_chunks(self, source):

        dom = Dom()
        prev_markup_cls = None
        self._stack = []
        for line in source:
            line = line.rstrip()

            # Handle rule comments
            if self._language.rule_filter(line):
                continue

            # Lookup for markup
            markup_cls, line = self._parse_line(line)

            # Fixme: invalid markup
            # self._logger.info('Markup {} \n'.format(markup_cls) + line.rstrip())

            # new chunk ?
            if markup_cls != prev_markup_cls:
                chunk = markup_cls(self)
                dom.append(chunk)

            # Skip enclosing markup lines
            if line is not None:
                dom.last_chunk.append(line)

            prev_markup_cls = markup_cls

        return dom

    ##############################################

    def _post_process_dom(self, raw_dom):

        # Fixme: run code in parallel ???
        figure_evaluator = FigureEvaluator()

        dom = Dom()
        for chunk in raw_dom.iter_on_not_empty_chunk():
            previous_chunk = dom.last_chunk
            if isinstance(chunk, CommentChunk):
                continue
            elif previous_chunk is not None and previous_chunk.mergable(chunk):
                previous_chunk.merge(chunk)
            elif isinstance(chunk, InteractiveCodeChunk):
                for line_chunk in chunk.to_line_chunk():
                    dom.append(line_chunk)
            elif isinstance(chunk, FigureChunk):
                for figure_command in figure_evaluator.eval(str(chunk)):
                    figure_chunk = figure_command.to_chunk(self)
                    dom.append(figure_chunk)
            else:
                if isinstance(chunk, OutputChunk):
                    if previous_chunk is not None and previous_chunk.is_executed:
                        chunk.code_chunk = previous_chunk
                    else:
                        raise NameError('Previous chunk must be code')
                elif isinstance(chunk, TextChunk):
                    if chunk.has_format():
                        chunk = chunk.to_rst_format_chunk()
                dom.append(chunk)

        return dom

    ##############################################

    def _has_title(self):

        """Return whether a title is defined."""

        # Fixme: test if first chunk ?
        for chunk in self._dom:
            if isinstance(chunk, RstChunk):
                content = str(chunk)
                if '='*(3+2) in content: # Fixme: hardcoded !
                    return True

        return False

    ##############################################

    def make_rst(self):

        """Generate the document RST file."""

        self._logger.info("\nCreate RST file {}".format(self._rst_path))

        # place the input file in the rst path
        link_path = self._topic.join_rst_path(self._input_file)
        if not os.path.exists(link_path):
            os.symlink(self._path, link_path)

        kwargs = {
            'input_file':self._input_file,
        }

        has_title = self._has_title()
        if not has_title:
            kwargs['title'] = self._basename.replace('-', ' ').title() # Fixme: Capitalize of

        template_aggregator = TemplateAggregator(self.settings.template_environment)
        template_aggregator.append('document', **kwargs)

        with open(self._rst_path, 'w') as fh:
            fh.write(str(template_aggregator))
            for chunk in self._dom:
                fh.write(chunk.to_rst())

    ##############################################

    def make_notebook(self):

        """Generate the notebook file."""

        notebook = nbv4.new_notebook()

        notebook.metadata.update(self.language.notebook_metadata)

        last_cell = None
        for chunk in self._dom:
            cell = None
            # Fixme: complete
            if isinstance(chunk, RstChunk):
                markdown = chunk.to_markdown()
                cell = nbv4.new_markdown_cell(markdown)
            elif isinstance(chunk, CodeChunk):
                code = chunk.to_code()
                cell = nbv4.new_code_cell(code)
                for output in chunk.outputs:
                    cell.outputs.append(output.node)
            elif last_cell is not None and isinstance(chunk, ImageChunk):
                node = chunk.to_node()
                if node is not None:
                    last_cell.outputs.append(node)
            if cell is not None:
                notebook.cells.append(cell)
                last_cell = cell

        path = self._topic.join_rst_path(self.nb_filename)
        self._logger.info("\nCreate Notebook file {}".format(path))
        with open(path, 'w') as fh:
            nbformat.write(notebook, fh)
